import pandas as pd
import numpy as np

def ks_por_decil(df, score_col, target_col, flag_col='Flag_Base', n_decis=10):
    # Cria um dataframe com as colunas de score, target e flag
    df_ks = pd.DataFrame({score_col: df[score_col], target_col: df[target_col], flag_col: df[flag_col]})

    # Divide a variável de score em n_decis decis usando a função qcut do pandas
    df_ks['decil'] = pd.qcut(df_ks[score_col], n_decis, labels=False) + 1

    # Cria um dataframe com as estatísticas de cada decil e categoria
    df_decis = df_ks.groupby([flag_col, 'decil']).agg({score_col: ['min', 'max', 'count'], target_col: 'sum'})

    # Cria colunas para o número acumulado de observações e eventos
    df_decis['cumulative_count'] = df_decis[score_col]['count'].cumsum()
    df_decis['cumulative_event'] = df_decis[target_col]['sum'].cumsum()

    # Calcula as proporções acumuladas de observações e eventos
    total_count = df_decis[score_col]['count'].sum()
    total_event = df_decis[target_col]['sum'].sum()
    df_decis['cumulative_percent'] = df_decis['cumulative_count'] / total_count
    df_decis['cumulative_event_percent'] = df_decis['cumulative_event'] / total_event

    # Calcula as proporções acumuladas de não eventos
    df_decis['cumulative_non_event_percent'] = (df_decis['cumulative_count'] - df_decis[target_col]['sum']) / (total_count - total_event)

    # Calcula a diferença entre as proporções acumuladas de eventos e não eventos
    df_decis['ks'] = df_decis['cumulative_event_percent'] - df_decis['cumulative_non_event_percent']

    # Cria um dicionário para armazenar os valores de KS de cada categoria
    ks_dict = {}

    # Calcula o KS para cada categoria da coluna Flag_Base
    for category in df[flag_col].unique():
        try:
            # Seleciona o dataframe correspondente à categoria
            df_cat = df_decis.loc[category, :]

            # Armazena o valor máximo da diferença entre as proporções acumuladas de eventos e não eventos (KS)
            ks_dict[category] = df_cat['ks'].max()
        except KeyError:
            # Caso a categoria não esteja presente no dataframe, armazena um valor nulo
            ks_dict[category] = None

    # Armazena o valor máximo do KS da base completa
    ks_dict['Total'] = df_decis.loc[:, 'ks'].max()

    # Retorna o dicionário com os valores de KS de cada categoria e da base completa
    return ks_dict



import pandas as pd
import statsmodels.api as sm

# Carrega a base de dados completa
df_completa = pd.read_csv('caminho/do/arquivo.csv')

# Define as variáveis explicativas do modelo
variaveis = ['var1', 'var2', 'var3']

# Extrai os coeficientes do modelo treinado
coeficientes = list(logit_model.params)

# Remove o intercepto da lista de coeficientes
coeficientes.pop(0)

# Cria uma nova coluna na base de dados para armazenar as previsões
df_completa['previsoes'] = 0

# Itera sobre cada linha da base de dados e calcula a previsão
for index, row in df_completa.iterrows():
    previsao = 0
    for i in range(len(variaveis)):
        previsao += row[variaveis[i]] * coeficientes[i]
    df_completa.loc[index, 'previsoes'] = previsao

# Visualiza as previsões
print(df_completa['previsoes'])

