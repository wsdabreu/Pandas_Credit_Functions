import pandas as pd
import numpy as np

def ks_por_decil(df, score_col, target_col, flag_col='Flag_Base', n_decis=10):
    # Cria um dataframe com as colunas de score, target e flag
    df_ks = pd.DataFrame({score_col: df[score_col], target_col: df[target_col], flag_col: df[flag_col]})

    # Divide a variável de score em n_decis decis usando a função qcut do pandas
    df_ks['decil'] = pd.qcut(df_ks[score_col], n_decis, labels=False) + 1

    # Cria um dataframe com as estatísticas de cada decil e categoria
    df_decis = df_ks.groupby([flag_col, 'decil']).agg({score_col: ['min', 'max', 'count'], target_col: 'sum'})

    # Cria colunas para o número acumulado de observações e eventos
    df_decis['cumulative_count'] = df_decis[score_col]['count'].cumsum()
    df_decis['cumulative_event'] = df_decis[target_col]['sum'].cumsum()

    # Calcula as proporções acumuladas de observações e eventos
    total_count = df_decis[score_col]['count'].sum()
    total_event = df_decis[target_col]['sum'].sum()
    df_decis['cumulative_percent'] = df_decis['cumulative_count'] / total_count
    df_decis['cumulative_event_percent'] = df_decis['cumulative_event'] / total_event

    # Calcula as proporções acumuladas de não eventos
    df_decis['cumulative_non_event_percent'] = (df_decis['cumulative_count'] - df_decis[target_col]['sum']) / (total_count - total_event)

    # Calcula a diferença entre as proporções acumuladas de eventos e não eventos
    df_decis['ks'] = df_decis['cumulative_event_percent'] - df_decis['cumulative_non_event_percent']

    # Cria um dicionário para armazenar os valores de KS de cada categoria
    ks_dict = {}

    # Calcula o KS para cada categoria da coluna Flag_Base
    for category in df[flag_col].unique():
        try:
            # Seleciona o dataframe correspondente à categoria
            df_cat = df_decis.loc[category, :]

            # Armazena o valor máximo da diferença entre as proporções acumuladas de eventos e não eventos (KS)
            ks_dict[category] = df_cat['ks'].max()
        except KeyError:
            # Caso a categoria não esteja presente no dataframe, armazena um valor nulo
            ks_dict[category] = None

    # Armazena o valor máximo do KS da base completa
    ks_dict['Total'] = df_decis.loc[:, 'ks'].max()

    # Retorna o dicionário com os valores de KS de cada categoria e da base completa
    return ks_dict



def get_logit_equation(logit_model):
    equation = '1 / (1 + exp(-('
    coef = logit_model.params
    var_names = coef.index
    for i, name in enumerate(var_names):
        if i == 0:
            continue  # Intercepto não é incluído na equação
        if coef[name] >= 0:
            sign = '+'
        else:
            sign = '-'
        equation += sign + f' {abs(coef[name]):.4f} * {name}'
    equation += ')))'
    return equation
